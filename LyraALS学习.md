## 01 Animation BluePrints

几种播放动画的方法：

1. Sequence Player -> Output Pose

   ![1765354469150](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230310063-1021684691.png)
2. 变量传入Sequence Player -> Output Pose

   ![1765354564173](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230310633-2106405544.png)

   ![1765354575160](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230310923-569039745.png)

## 02 Blueprint communication Intermediate

##### 蓝图之间的三种通信方式

Casting(**投射**)

Interfaces(**接口**)

Property Access(**属性访问**)

##### Blueprint casting

初始化时，Pawn -> Cast to 目标Character -> 拿到移动组件的引用

![1765442336806](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230311322-624404674.png)

Update每帧从移动组件里读数据

![1765442469726](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230311722-388541828.png)

##### Blueprint Interfaces

新建一个动画蓝图接口：

![1765444437383](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230312010-363048062.png)

![1765444550152](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230312392-2139473818.png)

在角色动画蓝图中，继承接口：

![1765444694691](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230312807-897775939.png)

![1765444707546](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230313104-412863311.png)

一个单纯的动画事件、一个有传参的方法

![1765444567536](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230313401-933734509.png)

![1765444848280](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230313798-1043880465.png)

角色蓝图：

![1765444933530](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230314311-111652710.png)

##### Property Access

角色动画蓝图中：

先新建一个线程安全的Update，

![1765445448796](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230314687-1243633538.png)

然后新建一个函数，

![1765446585236](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230315105-1057599292.png)

返回节点要勾选Pure(**全程只读取数据、不修改任何内容**)

![1765446607600](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230315429-573026676.png)

回到线程安全的Update，调用新建函数

![1765446857523](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230315901-750043301.png)

## 03 Idle Animations Pro

### Input System

![1765972150220](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230316244-783876310.png)

![1765972201519](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230316700-194988140.png)

![1765972276299](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230317188-941446347.png)

### 先实现数字键123对应打印字符123：

1.数字键2和3加上输入Modifiers修饰器(修改原始输入数据)——Scalar(标量：相当于给输入值乘一个系数)

![1765973598925](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230317587-46047028.png)

2.角色蓝图中，初始事件中调用AddMappingContext传入InputMapping，增强输入系统事件打印InputActions的值(按下瞬间触发)

![1765974451741](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230318061-1839375998.png)

> **EnhancedInputAction（增强输入动作）的事件参数：**
>
> 1. **`Triggered`**：按住按键时调用的事件。
> 2. **`Started`**：按下按键的瞬间调用的事件。
> 3. **`Ongoing`：**输入动作处于**持续激活状态中**的事件（类似 `Triggered`的持续反馈）。
> 4. **`Canceled`**：输入动作被 **中断 / 取消时** （比如按了一半突然松开按键）调用的事件。
> 5. **`Completed`**：输入动作 **完成触发后** （比如按键按下后完全松开）调用的事件。
> 6. **`Action Value`**：输入动作对应的 **具体数值** （比如摇杆的 X/Y 轴值、扳机键的按压程度），是最常用的参数之一。
> 7. **`Elapsed Seconds`**：输入动作从 “开始” 到当前的 **已持续时间** （单位：秒）。
> 8. **`Triggered Seconds`**：输入动作处于 “触发状态” 的 **累计时间** （可能包含多次触发的总和）。
> 9. **`Input Action`**触发的 **输入动作本身的引用** （可以通过它获取动作的配置信息）。

在Game中就实现了：

![1765973996543](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230318478-642625850.png)

> 其他Modifiers：
>
> * **None** ：不使用任何修饰器，直接传递原始输入值。
> * **Dead Zone（死区）** ：忽略手柄摇杆 / 扳机键的微小输入（比如摇杆漂移），低于阈值的输入会被视为 0。
> * **FOV Scaling（视场缩放）** ：根据当前相机的 FOV（视场角）调整输入值的大小。
> * **Negate（否定）** ：反转输入值（比如将 “1” 变成 “-1”），常用于反转轴方向（如相机 Y 轴）。
> * **Response Curve - Exponential（响应曲线 - 指数）** ：给输入值套指数曲线，让小幅度输入更细腻、大幅度输入更灵敏（适合瞄准类操作）。
> * **Response Curve - User Defined（响应曲线 - 自定义）** ：用用户自己绘制的曲线来调整输入响应。
> * **Scalar（标量）** ：给输入值乘以一个系数，用于调整灵敏度（比如把移动速度放大 2 倍）。
> * **Scale By Delta Time（按 DeltaTime 缩放）** ：输入值乘以每帧的时间间隔，让输入效果不受帧率影响。
> * **Smooth（平滑）** ：对多帧输入做平滑处理，减少输入抖动。
> * **Swizzle Input Axis Values（交换输入轴值）** ：交换输入的坐标轴顺序（比如把 X 轴输入映射到 Y 轴）。
> * **To World Space（转世界空间）** ：将本地空间的输入（比如角色自身坐标系）转换为世界

### 如何传递参数到动画蓝图中

1.创建一个枚举类型

![1765974356655](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230318825-20118294.png)

2.角色蓝图新建该枚举类型的变量

![1765975528417](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230319118-1739255602.png)

![1765975545646](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230319423-1053883599.png)

3.用switch on int根据输入的123转换为三个枚举变量，打印

![1765975636143](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230319893-464023370.png)

> `Truncate`（截断节点）:
>
> **把 `Action Value`可能出现的浮点数转为整数** （比如输入值是 “1.2” 会被截断成 “1”）

效果：

![1765975719338](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230320357-1061466892.png)

4.枚举类型EquippedGun —>动画蓝图

AnimationBluePrintsInterface中新建一个方法，传入参数为该枚举类型：

![1765977854332](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230320710-837707472.png)

动画蓝图中定义该方法，

![1765977902093](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230321144-1752820277.png)

角色蓝图中通过Mesh引一个动画实例传入该方法，

![1765977977721](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230321661-667019078.png)

这样EnhancedInputSystem事件中输入的参数就传入了动画蓝图，与前面角色蓝图中直接传递参数的效果一致

![1765983828001](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230426630-893023346.png)

> 解决相机显示问题：
>
> 角色组件中，
>
> ![1765978905491](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230322853-230210340.png)

### 动画状态机

> 和unity Animator很像，但因为有事件系统，其实更像是animancer的可视化

动画蓝图中新建一个状态机，

![1765980534744](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230323393-541580808.png)

构建跳转关系，

![1765980572329](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230323745-1085023717.png)

每个State绑定对应的动画资产，

![1765980685669](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230324075-1370396019.png)

勾选上循环动画，

![1765980698984](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230324356-796613781.png)

跳转条件，

![1765980767670](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230324682-34678546.png)

把跳转条件promote为shared transition，

![1765980962567](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230325054-1338387869.png)

效果：

![1765981540642](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230329046-507351989.gif)

### Blend Poses 姿势混合

#### Blend Poses by Int

![1765982012375](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230329796-2001453095.png)

#### Blend Poses by Enum(最常用)

![1765982146749](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230330296-774720806.png)

### Dynamic sequence with blend inertialization

![1765983523577](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230330674-876476647.png)

![1765983530790](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230331074-866081365.png)

带 Inertial Blending 的 Set Sequence 方法：需要有Inertialization才能正常运作

> Inertialization（惯性混合节点）：
>
> 让 “旧待机动画的动量” 在 0.2 秒内衰减，平滑过渡到新的待机动画。
