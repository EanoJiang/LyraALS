## 01 Animation BluePrints

几种播放动画的方法：

1. Sequence Player -> Output Pose

   ![1765354469150](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230310063-1021684691.png)
2. 变量传入Sequence Player -> Output Pose

   ![1765354564173](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230310633-2106405544.png)

   ![1765354575160](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230310923-569039745.png)

## 02 Blueprint communication Intermediate

##### 蓝图之间的三种通信方式

Casting(**投射**)

Interfaces(**接口**)

Property Access(**属性访问**)

##### Blueprint casting

初始化时，Pawn -> Cast to 目标Character -> 拿到移动组件的引用

![1765442336806](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230311322-624404674.png)

Update每帧从移动组件里读数据

![1765442469726](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230311722-388541828.png)

##### Blueprint Interfaces

新建一个动画蓝图接口：

![1765444437383](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230312010-363048062.png)

![1765444550152](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230312392-2139473818.png)

在角色动画蓝图中，继承接口：

![1765444694691](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230312807-897775939.png)

![1765444707546](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230313104-412863311.png)

一个单纯的动画事件、一个有传参的方法

![1765444567536](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230313401-933734509.png)

![1765444848280](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230313798-1043880465.png)

角色蓝图：

![1765444933530](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230314311-111652710.png)

##### Property Access

角色动画蓝图中：

先新建一个线程安全的Update，

![1765445448796](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230314687-1243633538.png)

然后新建一个函数，

![1765446585236](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230315105-1057599292.png)

返回节点要勾选Pure(**全程只读取数据、不修改任何内容**)

![1765446607600](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230315429-573026676.png)

回到线程安全的Update，调用新建函数

![1765446857523](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230315901-750043301.png)

## 03 Idle Animations Pro

### Input System

![1765972150220](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230316244-783876310.png)

![1765972201519](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230316700-194988140.png)

![1765972276299](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230317188-941446347.png)

### 先实现数字键123对应打印字符123：

1.数字键2和3加上输入Modifiers修饰器(修改原始输入数据)——Scalar(标量：相当于给输入值乘一个系数)

![1765973598925](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230317587-46047028.png)

2.角色蓝图中，初始事件中调用AddMappingContext传入InputMapping，增强输入系统事件打印InputActions的值(按下瞬间触发)

![1765974451741](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230318061-1839375998.png)

> **EnhancedInputAction（增强输入动作）的事件参数：**
>
> 1. **`Triggered`**：按住按键时调用的事件。
> 2. **`Started`**：按下按键的瞬间调用的事件。
> 3. **`Ongoing`：**输入动作处于**持续激活状态中**的事件（类似 `Triggered`的持续反馈）。
> 4. **`Canceled`**：输入动作被 **中断 / 取消时** （比如按了一半突然松开按键）调用的事件。
> 5. **`Completed`**：输入动作 **完成触发后** （比如按键按下后完全松开）调用的事件。
> 6. **`Action Value`**：输入动作对应的 **具体数值** （比如摇杆的 X/Y 轴值、扳机键的按压程度），是最常用的参数之一。
> 7. **`Elapsed Seconds`**：输入动作从 “开始” 到当前的 **已持续时间** （单位：秒）。
> 8. **`Triggered Seconds`**：输入动作处于 “触发状态” 的 **累计时间** （可能包含多次触发的总和）。
> 9. **`Input Action`**触发的 **输入动作本身的引用** （可以通过它获取动作的配置信息）。

在Game中就实现了：

![1765973996543](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230318478-642625850.png)

> 其他Modifiers：
>
> * **None** ：不使用任何修饰器，直接传递原始输入值。
> * **Dead Zone（死区）** ：忽略手柄摇杆 / 扳机键的微小输入（比如摇杆漂移），低于阈值的输入会被视为 0。
> * **FOV Scaling（视场缩放）** ：根据当前相机的 FOV（视场角）调整输入值的大小。
> * **Negate（否定）** ：反转输入值（比如将 “1” 变成 “-1”），常用于反转轴方向（如相机 Y 轴）。
> * **Response Curve - Exponential（响应曲线 - 指数）** ：给输入值套指数曲线，让小幅度输入更细腻、大幅度输入更灵敏（适合瞄准类操作）。
> * **Response Curve - User Defined（响应曲线 - 自定义）** ：用用户自己绘制的曲线来调整输入响应。
> * **Scalar（标量）** ：给输入值乘以一个系数，用于调整灵敏度（比如把移动速度放大 2 倍）。
> * **Scale By Delta Time（按 DeltaTime 缩放）** ：输入值乘以每帧的时间间隔，让输入效果不受帧率影响。
> * **Smooth（平滑）** ：对多帧输入做平滑处理，减少输入抖动。
> * **Swizzle Input Axis Values（交换输入轴值）** ：交换输入的坐标轴顺序（比如把 X 轴输入映射到 Y 轴）。
> * **To World Space（转世界空间）** ：将本地空间的输入（比如角色自身坐标系）转换为世界

### 如何传递参数到动画蓝图中

1.创建一个枚举类型

![1765974356655](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230318825-20118294.png)

2.角色蓝图新建该枚举类型的变量

![1765975528417](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230319118-1739255602.png)

![1765975545646](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230319423-1053883599.png)

3.用switch on int根据输入的123转换为三个枚举变量，打印

![1765975636143](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230319893-464023370.png)

> `Truncate`（截断节点）:
>
> **把 `Action Value`可能出现的浮点数转为整数** （比如输入值是 “1.2” 会被截断成 “1”）

效果：

![1765975719338](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230320357-1061466892.png)

4.枚举类型EquippedGun —>动画蓝图

AnimationBluePrintsInterface中新建一个方法，传入参数为该枚举类型：

![1765977854332](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230320710-837707472.png)

动画事件蓝图中定义该方法，

![1765977902093](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230321144-1752820277.png)

角色蓝图中通过Mesh引一个动画实例传入该方法，

![1765977977721](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230321661-667019078.png)

这样EnhancedInputSystem事件中输入的参数就传入了动画蓝图，与前面角色蓝图中直接传递参数的效果一致

![1765983828001](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230426630-893023346.png)

> 解决相机显示问题：
>
> 角色组件中，
>
> ![1765978905491](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230322853-230210340.png)

### 动画状态机

> 和unity Animator很像，但因为有事件系统，其实更像是animancer的可视化

动画蓝图中新建一个状态机，

![1765980534744](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230323393-541580808.png)

构建跳转关系，

![1765980572329](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230323745-1085023717.png)

每个State绑定对应的动画资产，

![1765980685669](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230324075-1370396019.png)

勾选上循环动画，

![1765980698984](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230324356-796613781.png)

跳转条件，

![1765980767670](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230324682-34678546.png)

把跳转条件promote为shared transition，

![1765980962567](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230325054-1338387869.png)

效果：

![1765981540642](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230329046-507351989.gif)

### Blend Poses 姿势混合

#### Blend Poses by Int

![1765982012375](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230329796-2001453095.png)

#### Blend Poses by Enum(最常用)

![1765982146749](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230330296-774720806.png)

### Dynamic sequence with blend inertialization

![1765983523577](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230330674-876476647.png)

![1765983530790](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251217230331074-866081365.png)

带 Inertial Blending 的 Set Sequence 方法：需要有Inertialization才能正常运作

> Inertialization（惯性混合节点）：
>
> 让 “旧待机动画的动量” 在 0.2 秒内衰减，平滑过渡到新的待机动画。

## 04 Linked Animations Pro

### AnimationLayer

![1766062591725](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234906538-1122188766.png)

![1766062621449](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234907059-1351549452.png)

IdleLayer中，

![1766066283063](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234907679-1555544737.png)

### AnimationLayer Interfaces

> 用接口的方式添加AnimationLayer

#### 1.新建AnimationLayer Interfaces——ALI_Lyra

![1766062806260](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234908042-1794429925.png)

![1766062912085](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234908326-734073746.png)

#### 2.在ABP_Base的ClassSettings中添加接口

![1766063006799](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234908598-586777491.png)

IdleLayer和上面一样设置好之后加到动画蓝图中即可

![1766063116053](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234908874-1745111209.png)

![1766066615781](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234909282-1715672966.png)

### Link Anim Class

#### 1.新建一个AnimationBlueprints——ABP_Layers

> 继承接口ALI_Lyra

![1766063951154](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234909643-1811794073.png)

在IdleLayer中，新建一个变量IdleAnim(这个会在后面的子ABP中更改值)，传入SequencePlayer

![1766065775554](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234910014-990193264.png)

在角色事件蓝图中 Link Anim Class Layers，Class设置为ABP_Layers

![1766064024128](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234910443-1952638410.png)

这样就连接到了ABP_Layers

#### 2.创建ABP_Layers的子ABP

![1766064697561](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234910790-1226613406.png)

设置好各自的默认值

![1766064710349](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234911078-211973741.png)

![1766064742905](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234911355-411621758.png)

![1766064732357](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234911635-1149983132.png)

角色事件蓝图中，Link Anim Class Layers到各个子ABP_Layer

![1766064777427](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234912073-1258813149.png)

ABP_Layers中，

![1766065863852](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234912494-2018411387.png)

![1766065898221](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234912879-852109440.png)

ABP_Layers只用来管理各种Layer，不做更多的事，惯性节点在ABP_Base中添加

![1766066000457](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234913259-975133569.png)

### 总结

ABP_Base 和ABP_Layers继承自 动画层接口ALI_Lyra(规定了各种Layer)

IdleLayer在ABP_Layers中的Idle On Update实现

ABP_Layers的Idle On Update中的变量IdleAnim在每个子ABP_Layer中更改默认值

IdleLayer在ABP_Base中传入(考虑惯性节点)

## 05 Organizing our work Beginner

> 整理蓝图

## 06 Character movement Beginner

> 角色移动

### 1.视角的移动

新建IA_Look

![1766069062801](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234913604-473936847.png)

![1766069084837](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234913906-1080370368.png)

在IMC_ALS中加进来

![1766069144497](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234914250-1878334999.png)

角色时间蓝图中

![1766069906852](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234914649-421760153.png)

SpringArm中勾上使用 Pawn 控制旋转

![1766069668067](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234914961-1318132508.png)

解决一下竖直方向视角移动反向的问题

![1766070042709](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234915250-271145390.png)

### 2.人物的移动

同样的做法

![1766070703455](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234915526-1206765278.png)

把轴向调正确

![1766072830440](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234915963-1385863777.png)

角色事件蓝图中

![1766072879935](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234916387-778628706.png)

![1766072890716](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251218234916887-584937498.png)

> 为什么左右移动只连xz，前后移动只连z？

## 07 Cycle Animation Part01 Intermediate

### 1.动画蓝图中新建一个LocomotionSM，将会包含Idle、Move等等

![1766146397815](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234821093-267037984.png)

![1766146407355](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234821592-98389344.png)

![1766146416184](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234821907-1334064399.png)

### 2.在线程安全UpdateAnimation函数中，新建一个函数GetVelocityData并调用

![1766148545232](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234822240-749581121.png)

![1766149347410](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234822581-1152916327.png)

注意GetVelocityData函数要勾上线程安全

![1766149293246](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234822872-678650320.png)

### 3.LocomotionSM状态机

![1766151728171](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234823179-1820695708.png)

![1766151908541](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234823532-614425713.png)

记得勾选Loop

![1766151949708](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234823817-511308430.png)

跳转条件

![1766151713826](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234824140-135817147.png)

![1766151992200](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234824501-452771942.png)

动画资产要启用Root Motion和Force Root Lock

![1766152162532](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234824787-1730247168.png)

效果

![1766153452856](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234829462-1148296018.gif)

### 4.Aim

#### Aim input

![1766153585653](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234830129-1542467509.png)

#### 创建E_Gate枚举类型，包含走路(瞄准时用到)和慢跑(不瞄准时用到)两个状态

![1766153891230](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234830406-246875596.png)

![1766153874093](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234830687-1486764295.png)

在角色事件蓝图中新建E_Gate枚举变量CurrentGate

![1766154095724](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234830968-15716248.png)

#### 创建S_GateSettings结构体

> 六个参数：
>
> 最大走路速度
>
> 最大加速度
>
> 制动减速度
>
> 制动制动摩擦力因素
>
> 制动摩擦力
>
> 使用单独的制动摩擦力

![1766154722205](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234831288-131006494.png)

角色事件蓝图中新建一个Key为E_Gate枚举类型，Value为S_GateSettings结构体类型的变量

![1766155795300](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234831570-406088322.png)

![1766155827491](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234831944-911502470.png)

#### 新建函数UpdateGate(E_Gate Gate)

![1766156045886](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234832316-199330092.png)

![1766156963791](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234832972-1657013436.png)

瞄准Started时更新当前Gate为Walking，Completed时为Jogging

![1766157046751](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234833435-1094990585.png)

效果：

![1766157396915](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234839943-876962296.gif)

这里只是根据状态不同更新Character Movement的速度

#### 在动画蓝图中根据当前的状态切换对应动画

##### 在动画蓝图接口BPI_AnimationBlueprintsInterface中新建一个函数RecieveCurrentGate(E_Gate Gate)

![1766157612683](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234840578-1540719352.png)

动画事件蓝图中定义这个函数是用来设置CurrentGate的

![1766157936084](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234840942-208371353.png)

传参：角色事件蓝图中的UpdateGate()中把Set的CurrentGate值通过Anim Instance传入动画蓝图中的事件函数RecieveCurrentGate()

![1766158273899](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234841338-642407811.png)

下面只需要在ABP_Base的LocomotionSM中设置好动画资产即可

##### 在ABP_Base中的Cycle中姿势混合(with E_gate)，传入参数为CurrentGate

![1766159134918](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251219234841723-1151890376.png)

##### 把这个姿势混合逻辑放到ABP_Layers中

ALI_Lyra中加一个CycleLayer

![1766323669009](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251221234625126-1284690845.png)

把Cycle(State)的逻辑放到ABP_Layers的CycleLayer中

![1766324157023](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251221234625907-194319527.png)

这里的CurrentGate需要在ABP_Layers新建一个函数GetABPBase(Pure)，来获取ABP_Base中的函数和变量

![1766325041708](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251221234626451-1711734009.png)

在ABP_Layers的CycleLayer中就可以获取到CurrentGate这个参数了

![1766325445539](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251221234626903-1456058766.png)

和IdleOnUpdate一样，逻辑封装到CycleOnUpdate中，然后CycleAnim变量在每个子ABP_Layer中设置对应动画资产

![1766328494884](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251221234627265-1600848144.png)

![1766328535006](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251221234627694-36516877.png)

> 注意：这些Anim变量都不用设置默认值
>
> 我们应该在角色事件蓝图的初始化中设置Anim Class为ABP_UnarmedLayer：
>
> ![1766329903943](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251221234628193-534708978.png)

各子ABP_Layer的资产设置:

以ABP_Pistol为例，

![1766328565701](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251221234628516-73355935.png)

> 如何批量设置动画资产的RootMotion：
>
> ![1766327868432](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251221234628907-1498521353.png)
>
> ![1766327907003](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251221234629312-2094306299.png)
>
> ![1766327841572](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251221234629783-1197221970.png)

效果：

![1766330258161](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251221234637347-1686160871.gif)

## 08 Debug Options Intermediate

> 调试

### DebugPrint

![1766574047115](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212520696-1332458117.png)

![1766574061741](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212521350-1272282163.png)

![1766574073286](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212521808-546618985.png)

![1766574095327](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212522291-954584215.png)

效果：

![1766574130117](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212522888-849570527.png)

### DebugDrawVector

#### 1.需要在角色脚下画箭头就需要先获取到角色的世界坐标

![1766574944027](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212523174-296864245.png)

![1766574920215](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212523570-697261091.png)

勾上线程安全后连到：

![1766574972902](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212523951-1263501940.png)

#### 2.Debug Draw Vector

线的起始和最终位置只需要xy两个维度

![1766577063572](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212524433-898272920.png)

![1766577075299](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212524816-1551329138.png)

![1766576832978](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212525195-714139665.png)

效果：

![1766577189184](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212526095-415318474.png)

### 建立一个Debug系统管理上面的Debug方法

新建一个结构体S_DebugOptions

![1766578898082](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212526478-647688543.png)

![1766578909183](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212526812-798556515.png)

ABP_Base中新建该结构体变量

![1766578952083](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212527085-869462258.png)

以及函数Debug，把之前事件蓝图中的Debug方法移进来，用DebugOptions结构体变量做if判断执行对应的Debug方法

![1766578854938](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212527521-529256806.png)

![1766578982545](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212527992-565901421.png)

回到事件蓝图中连上Debug即可

![1766579363646](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212528393-491185361.png)

### Debug慢动作模式

角色事件蓝图中用Set Global Time Dilation：时间膨胀系数越小越慢

![1766579786090](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251224212528826-1575373723.png)

## 09 Cycle animation Part02 Pro

### 先获取RotationData

![1766831632555](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193927004-2004400978.png)

![1766831528399](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193927769-2129788301.png)

### 更新当前朝向(2d，只有xy)

![1766831880028](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193928376-182815813.png)

![1766833413385](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193928739-1465192772.png)

在Debug中显示当前朝向

![1766833480038](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193929220-1160059498.png)

前后左右分别是：

![1766835258081](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193929658-1136378240.png)

下面就可以根据这个朝向设置不同的转向动画资产

### 新建一个移动方向的枚举类型

![1766834639310](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193930095-1379371252.png)

![1766834629098](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193930398-1043332023.png)

然后在ABP_Base中创建该枚举变量

![1766834729497](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193930742-166776203.png)

### 计算移动方向

后：

![1766835023827](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193931137-95871008.png)

前：

![1766835233241](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193931563-604478914.png)

更新朝向的时候计算移动方向

![1766835445233](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193931969-510491417.png)

Debug显示出来

![1766835337542](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193932348-1011737421.png)

效果：

![1766835516431](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193933599-870841015.png)

![1766835554438](https://img2024.cnblogs.com/blog/3614909/202512/3614909-20251227193935024-1953655540.png)

左右方向的计算同理：
